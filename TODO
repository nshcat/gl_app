- Research ECS (entity component system) https://github.com/phiste/kengine <- on bottom of page there is an example

- Put begin_frame and end_frame into render_context

- Add a way to sample color values from a distribution to draw! (maybe foreground(sampled(dist, gen)))
	=> Would allow draw() to use that!
		=> Make the actions sample_background better!

- Implement palettes: screen_manager has a reference to a palette instance
	=> When choosing colours, it is possible to either use RGB (`foreground({244, 33, 32})`) or a palette color (`foreground(color::light_red)`)
	=> RenderManager gets palette reference, it should be loaded from disk
	
- With palettes implemented, implement `format_text(...)` which supports colours
	=> How?
		(1) Format string normally
		(2) Split string at color markers
		(3) Print sequentially with correct colors
	=> Format would need to be like `%%{BLK}` or something like that

- Introduce "clean areas", areas that will be cleaned up on next begin_frame!
- Reimplement profiling
- Add option to disable debug mode in render_context (constructor: `debug_mode(true)`)
- OpenGL cleanup in destructors!

- /!\ Lighting could be wrong!
	=> Normally, the lighting equation is as follows: k_d * I_L * c_L
		where I_L and c_L are the intensity and colour of the i-th light source, and k_d the diffuse albedo of the
		surface (in this case, texel of the gylph texture). ==>> WHICH SHOULD BE A 3D COLOR VECTOR! <<==
		This multiplication causes e.g. red light to not show up on a completely green surface!
		But in our case, this is not the case! We just add up all the light sources.
			=> THIS IS WRONG. A green surface is green BECAUSE IT ABSORBS ALL RED LIGHT. So
			it won't magically turn red when lit by a red light source!
				=> GOOD NEWS: A fix is easy. The lighting equation just needs to be adjusted.
				
	=> CAREFUL: Not mixing of the tex color with lighting! The texcolor is only the k_d value, no lights no color
		=> directly follow lambert diffuse term
		=> PROBLEM: Maybe we cant do it in VS anymore
			=> IF SO: Raytrace, and e.g. save flags if lights are visible using integral bit field, and then 
				access light data in FS aswell to calculate light.
				=> OR: just save accumulated irradiance
				

- fog should use integral distance values, like "this tile is two tiles beneath the current main z-level"

- Refactor different parts of the game into separate namespaces (gfx, input, rng ...)
- Global defined types for glyphs, colors, position.. (real_position, position, color, real_color) etc /!\ VERY IMPORTANT
- Random class that supports all kinds of operations. One, global, auto-seeded (e.g. time, random_device) instance (instance()) for game rng,
  but random should also be constructible for local RNG (map gen, using fixed seed to replicate mapgen)
  - IMPORTANT: Refactor main.src! Currently, all values are part of main() thats bad, because nothing can be put into functions!
  		=> Either put it into global state, or wrap as much as possible with classes (render_manager contains glfw.. etc, nk_manager, debug_ui ..)
  		
- IDEA: All classes that need to be global state: NO INITIALIZATION IN CTOR! (because order isnt garuantueed) Add initialize() method!

- Replace GLFW with SDL2? Or make new input handler?
	=> IMPORTANT: A single GLFW_PRESS Event should only count ONCE. if it is GLFW_REPEAT Keep it pressed until
		GLFW_UP
		OR BETTER: only use the polling functions. They should return the proper value.
		
		=> NO: polling functions can not implement repeat delay :)
		=> Two interfaces: one using the polling functions (no repeat delay), one using the callbacks (repeat delay)
			=> Basically: When Key is pressed using GLFW_PRESS, flag it to be cleared BEFORE NEXT FRAME.
				Only if it is pressed using GLFW_REPEAT it will be set as DONT_CLEAR, and thus persist.
				When GLFW_RELEASE is encountered, everything about the key is reset.
					=> IMPORTANT: Look at demo implementation in main.cxx for how modifier keys will work perfectly! :)
		  => Additionally: character stream functionality for text boxes :)
		  
		  
nuklear_gui::initialize(const render_manager::handle_type) => Needs window pointer aka. window handle

- render_manager with ::frame( ); method.
	-> and ::screen();
	-> is initialized with ::initialize() and contains shader program, screen, lights and textures
	-> Other things are drawn by supplying the screen to them
	
	
- high level drawing functions: e.g. `border(...)` returns a lambda that can be given to a new overload of `screen::modify`:
	=> 	auto border(...)
		{
			return [](screen_manager& scr)
			{
				scr.modify(...);
				scr.modify(...);
				scr.modify(...);
			};
		}
		
	=> screen.modify(border(...));
	
	template< TL, TR, BL, BR, ... >
	class border_style
	{
		static constexpr .... 
	};
	
	
	using thick_border_style = ...
	using slim_border_style = ...
	
	=> One can create custom border styles by inheritance and then overriding single members
		
