# Version requirement and project info
cmake_minimum_required(VERSION 3.9)
project(roguelike)

## === BUILD OPTIONS ===
##

set(DISTRIBUTE 			OFF		CACHE BOOL 		"Create distribution folder"						)
set(PREFIX 				"/usr" 	CACHE STRING 	"Game install prefix"								)	# This is unused if the game is used in portable (distribute) form.
set(USE_HOME_DIR		OFF		CACHE BOOL 		"Use home directory for user data"					)
set(CLANG_TIDY 			OFF		CACHE BOOL 		"Analyze source with clang-tidy"					)
set(USE_FIXED_STL 		OFF		CACHE BOOL 		"Use fixed version of libstdcxx <variant> header"	)
set(USE_LTO		 		OFF		CACHE BOOL 		"Utilize Link-Time-Optimization"					)
set(BUILD_SHARED_LIB	OFF		CACHE BOOL 		"Build as libascii"									)

## =====================

# Setup module path
set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR}/cmake)

# Import required CMake modules
include(Color)

# Show current build options to user
macro(print_switch sw desc)
	if(${sw})
		message("${BoldWhite} ${desc}${Green}ON${ColourReset}")
	else()
		message("${BoldWhite} ${desc}${Red}OFF${ColourReset}")
	endif()
endmacro()

macro(print_str val desc)
	message("${BoldWhite} ${desc}${ColourReset}${val}")
endmacro()


message("${BoldWhite}Build settings =================================${ColourReset}")
print_str(${PREFIX} "PREFIX:          ")
print_switch(${USE_HOME_DIR} "USE_HOME_DIR:    ")
print_switch(${CLANG_TIDY} "CLANG_TIDY:      ")

# The distribute switch is only useful when using mingw
if(MINGW)
	print_switch(${DISTRIBUTE} "DISTRIBUTE:      ")
endif()
message("${BoldWhite}================================================${ColourReset}")
#

# Search for OpenGL
find_package(OpenGL REQUIRED)

# Search for SDL2 and SDL2_Image
find_package(SDL2 REQUIRED)
find_package(SDL2_image REQUIRED)

# Search for Boost
# Note that for header-only libraries like boost::property_tree,
# no component has to be specified here
find_package(Boost 1.56 REQUIRED COMPONENTS filesystem)

# Search for clang-tidy if enabled by user
if(CLANG_TIDY)
	find_program(
  		CLANG_TIDY_EXE
  		NAMES "clang-tidy"
  		DOC "Path to clang-tidy executable"
  	)
  	
  	# Check if clang-tidy was actually found
  	if(NOT CLANG_TIDY_EXE)
  		message(STATUS "/!\ clang-tidy not found!")
 	else()
 		message(STATUS "clang-tidy found: ${CLANG_TIDY_EXE}")
 		
 		# Create clang-tidy command
 		set(DO_CLANG_TIDY "${CLANG_TIDY_EXE}" "-checks=*,-readability-braces-around-statements,-google-readability-braces-around-statements,-google-readability-todo,-clang-analyzer-alpha.*")
 	endif()
endif()

# Disable glfw examples and tests
set(GLFW_BUILD_EXAMPLES OFF CACHE BOOL "bla")
set(GLFW_BUILD_TESTS OFF CACHE BOOL "bla")
set(GLFW_BUILD_DOCS OFF CACHE BOOL "bla")
set(GLFW_INSTALL OFF CACHE BOOL "bla")

# Add openGL support libraries
add_subdirectory(glfw)
add_subdirectory(glxw)
add_subdirectory(cl)
add_subdirectory(ut)
add_subdirectory(log)
add_subdirectory(nuklear_cmake)
add_subdirectory(Remotery)
add_subdirectory(minitrace)

# Disable tests for the json library because they take a long time to build
set(JSON_BuildTests OFF CACHE BOOL "Tests")
add_subdirectory(json)

# Source files
file(GLOB SOURCE_FILES src/*.cxx)

# Headers
file(GLOB HEADER_FILES include/*.hxx)

# Define target as either executable or shared library, depending on settings
if(BUILD_SHARED_LIB)
	add_library(ascii SHARED ${SOURCE_FILES} ${HEADER_FILES})
	set_property(TARGET ascii PROPERTY POSITION_INDEPENDENT_CODE ON)
	set_property(TARGET ut PROPERTY POSITION_INDEPENDENT_CODE ON)
	set_property(TARGET log PROPERTY POSITION_INDEPENDENT_CODE ON)
	set_property(TARGET cl PROPERTY POSITION_INDEPENDENT_CODE ON)
	set_property(TARGET glxw PROPERTY POSITION_INDEPENDENT_CODE ON)
	set(TARGET_NAME ascii)
else()
	add_executable(roguelike ${SOURCE_FILES} ${HEADER_FILES})
	set(TARGET_NAME roguelike)
endif()


# Own headers
target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include)

# GLFW headers
target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/glfw/include)

# GLM headers
target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/glm)

# GLXW headers. They will be generated by cmake and are thus placed in the binary dir.
target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_BINARY_DIR}/glxw/include)

# SDL2 and SDL2_Image headers
target_include_directories(${TARGET_NAME} PRIVATE ${SDL2_INCLUDE_DIR})
target_include_directories(${TARGET_NAME} PRIVATE ${SDL2_IMAGE_INCLUDE_DIR})

# Boost headers
target_include_directories(${TARGET_NAME} PRIVATE ${Boost_INCLUDE_DIRS})

# Use fixed STL headers if requested
if(USE_FIXED_STL)
	target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/fixed_stl)
	target_compile_definitions(${TARGET_NAME} PUBLIC -DROGUELIKE_FIXED_STL=1)
endif()


# Link dependencies
target_link_libraries(	${TARGET_NAME} glfw glxw ${LIBMINITRACE_LIBRARIES}
						${NUKLEAR_LIBRARIES} ${NUKLEAR_GLFW_OPENGL3_LIBRARIES}
						${GLFW_LIBRARIES} ${GLXW_LIBRARY} ${OPENGL_LIBRARY}
						${LIBUT_LIBRARIES} ${SDL2_LIBRARY} ${SDL2_IMAGE_LIBRARY}
						${LIBCL_LIBRARIES} ${LIBLOG_LIBRARIES} nlohmann_json
						${LIBREMOTERY_LIBRARIES} Boost::filesystem)						
						
# Set definitions
if(USE_HOME_DIR)
	target_compile_definitions(${TARGET_NAME} PUBLIC -DROGUELIKE_USE_HOME=true)
else()
	target_compile_definitions(${TARGET_NAME} PUBLIC -DROGUELIKE_USE_HOME=false)
endif()

# PREFIX only sets the install prefix, but ROGUELIKE_DATA_PATH has to directly
# point to the asset folder.
target_compile_definitions(${TARGET_NAME} PUBLIC -DROGUELIKE_DATA_PATH=${PREFIX}/share/${TARGET_NAME}/assets)


# Copy assets to output path
add_custom_command(
	TARGET ${TARGET_NAME}
	POST_BUILD
	COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_SOURCE_DIR}/assets $<TARGET_FILE_DIR:${TARGET_NAME}>/assets
)

# Require support for at least C++14.
set_property(TARGET ${TARGET_NAME} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${TARGET_NAME} PROPERTY CXX_STANDARD_REQUIRED ON)

# Attach clang-tidy operation to target if requested by user
if(CLANG_TIDY)
	set_property(TARGET ${TARGET_NAME} PROPERTY CXX_CLANG_TIDY "${DO_CLANG_TIDY}")
endif()

# Bundle dependencies on mingw
# TODO fix for BUILD_WITH_LIB
if(MINGW AND DISTRIBUTE AND NOT BUILD_SHARED_LIB)
	add_custom_command(
		TARGET ${TARGET_NAME}
		POST_BUILD
		COMMAND ${CMAKE_COMMAND} -E make_directory "distrib"
		COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_SOURCE_DIR}/mingw-bundledlls/mingw-bundledlls ${CMAKE_BINARY_DIR}/distrib/mingw-bundledlls
		COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_BINARY_DIR}/${TARGET_NAME}.exe ${CMAKE_BINARY_DIR}/distrib/${TARGET_NAME}.exe
		COMMAND ${CMAKE_COMMAND} -E copy_directory  ${CMAKE_BINARY_DIR}/assets ${CMAKE_BINARY_DIR}/distrib/assets
		COMMAND ${CMAKE_BINARY_DIR}/distrib/mingw-bundledlls --copy "${CMAKE_BINARY_DIR}/distrib/${TARGET_NAME}.exe"
		COMMAND ${CMAKE_COMMAND} -E remove ${CMAKE_BINARY_DIR}/distrib/mingw-bundledlls
	)
endif()

# Enable LTO if requested by user
if(USE_LTO)
	# Check for LTO support
	include(CheckIPOSupported)
	check_ipo_supported()
	
	# Enable it for ${TARGET_NAME}. The used libraries do not really need it.
	set_target_properties(${TARGET_NAME} PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE)

	# Append special linker flags. This both sets the linker to gold (which is required to use LTO) and
	# enable caching for faster recompiles.
	set(LTO_FLAGS "-fuse-ld=gold -Wl,--no-threads,--plugin-opt,cache-dir=${PROJECT_BINARY_DIR}/lto.cache")
	set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${LTO_FLAGS}")
endif()
